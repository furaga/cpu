
########################################################################
2012年  2月 17日 金曜日 20:07:45 JST

* 行きづまった。
* baudrate115200, prom10bit, float.sが動作でpush.

#----------------------------------------------------------------------#
2012年  2月 17日 金曜日 14:30:04 JST

* u232cのreceive部分をとある10erのを借りる。
  これでバグってたらバッファ関連のミスで確定。
  baudrate 115200
* I/Oのバグをとったら、シミュレータでレイトレを動かしたりする。

* perimさんのminicomの代わりとなる通信プログラムをget。
* レイトレのテストをする。

#----------------------------------------------------------------------#
2012年  2月 17日 金曜日 11:07:55 JST

* prom 10bits baudrate 9600, loopback.s
* prom 10bits baudrate 115200, loopback.s
  ファイルでデータを送信すると、最初の1Byteを逃すバグがある。


#----------------------------------------------------------------------#
2012年  2月 17日 金曜日 01:45:09 JST

* 66.0M / 9600 = 6875 = x"1ADB"
* 66.0M / 115200 = 572.9 (=573) = x"023d"
* 66.666666M / 115200 = 578.7 (=579) = x"0243"

* とある10erを参考にすると、
  wtime=>x"0243" receive: wtime + 290
  minicomの設定を変える必要がある。
  baud rateをあげればsendbufの大きさを小さくできる。

* 明日テストすること。
  - prom 10bits, baudrate 9600, loopback.s
  - prom 10bits, baudrate 115200, loopback.s
  	- wtime + xx も変更。
  - prom 14bits, baudrate 115200, float.s 念の為。
  - prom 14bits, baudrate 115200, min-rt.s with recvbuf filled 

* 変更する点
  - tmpl/macro.tmp prom_msb()
  - prom CoreGenerator
  - ../ise_space/for_ise2.py
  - ../ise_space/for_ise3.py
  - tmpl/io_dev.tmp recvbuf, recv_tail
 
########################################################################
2012年  2月 16日 木曜日 23:57:42 JST

* I/Oの致命的なバグ修正！気をつけてたはずのところなのにな。。。orz
  NU-MAに感謝。
* u232cのread_readyが'1'である時間が1clk長かった。

* baud rate 11520にあげたい。

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 21:08:55 JST

* design goal をminimize runtime に変更できた。
  これで論理合成にかかる時間を減らせる？

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 19:37:20 JST

* ioを修正してfib30が動作。
* u232cのreceiveのバグは修正できたが、ストールの仕組みがまだよくない。

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 18:33:12 JST

* めも。
  - recv_tail, recvbuf
  - prom(fetch.vhd, CoreGenerator) 

* リベンジ！
* sendbuf はリングバッファにすれば65536でいけるんじゃないか。


#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 16:54:58 JST

* u232cのreceiveを修正。start bit が来たら、countdown <= wtime + 1000
  とする。なんのための1000だったかな。それから、recv_ready を追加。
* 送られてくるデータの変調の安定したところのデータをとるため。
* stop bitの扱いが雑だったために、1Byteの送信で、2Byte受信しようと
  していたと思われる。最後のデータをstart bit として検知してしまう。

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 15:04:57 JST

* 下ので一度keyを押すと、２文字送信されるのがおかしい。
  2回ストールして欲しいところで１回しか行われない。

Loop:
	input %g3
	output %g3
	jmp Loop

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 13:55:51 JST

* iobufをひとつのクロックで同期して、ヘッドテイルの操作を行うようにした。
  fibはとりあえず動いた。もう一度ループバックを試す。
* 今日は15:00までしか時間がない。
* 目標：２週間でレイトレ完動。

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 13:18:04 JST

* iobufがdualportRamになっていて、ポートのクロックが別々なのがややこしい

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 12:09:57 JST

* sramをいれてfloat.sが期待通りに動作。
* loopback.s をテスト中。

	.init_heap_size	0

	Loop:
		input %g3
		output %g3
		jmp Loop

* 一回目は失敗した。recvbufに初期値が入っていた。
  これでもうまくいきそうだが修正してもう一度試す。

* 初期化終了の合図の0xaaが出力される前にinputのNYETでストールするのが
  おかしい。初っ端inputはうまくいかなそう。プログラムを変更して
  nopをloopback.sのはじめに詰める。

* やはりinputに問題ありか。RAMとしてちゃんと書く必要があるかも。
  もしくはFIFOなんてのもあるけど、動かしたことがあるRAMの方がいいか。

WARNING:PhysDesignRules:372 - Gated clock. Clock net
iounit/recv_busy_inv is
sourced by a combinatorial pin. This is not good design practice. Use
the CE pin to control the loading of data into the flip-flop.

Synthesizing Unit <io_dev>.  Related source file is
"/home/occho/cpuex/local/cpu/ise_space/io_dev.vhd".
WARNING:Xst:647 - Input <CPU_OUT<31:8>> is never used. This port will be
preserved and left unconnected if it belongs to a top-level block or it
belongs to a sub-block and the hierarchy of this sub-block is preserved.
Found 1138x8-bit dual-port RAM <Mram_recvbuf> for signal <recvbuf>.
Found 2048x8-bit dual-port RAM <Mram_sendbuf> for signal <sendbuf>.
Found 11-bit comparator equal for signal <NYET$cmp_eq0000> created at
line 97.
Found 11-bit up counter for signal <recv_head>.
Found 11-bit up counter for signal <recv_tail>.
Found 11-bit comparator equal for signal <send_empty$cmp_eq0000> created
at line 78.
Found 1-bit register for signal <send_go>.
Found 11-bit up counter for signal <send_head>.
Found 11-bit up counter for signal <send_tail>.
Found 8-bit register for signal <u232c_o>.
Summary:
inferred   2 RAM(s).
inferred   4 Counter(s).
inferred   9 D-type flip-flop(s).
inferred   2 Comparator(s).
Unit <io_dev> synthesized.


#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 02:18:50 JST

* vhdlも修正。むしろ正しかった？なにやら何を間違えていたか忘れた。
* Cのシミュレータで組み込んだfadd,fmulで正しく画像が出力されるように
  なったってことだったよな。
* あとはinputまわりと、SRAMの実機でのテスト。

* レイトレ命令発行数: 1447059804

#----------------------------------------------------------------------#
2012年  2月 16日 木曜日 01:59:21 JST

* faddがa + -aなどのときにおかしくなる点を修正。
* レイトレはCの組み込みと同じppmを出力する。
* vhdlの方も修正する。

########################################################################
2012年  2月 15日 水曜日 22:43:59 JST

* sramコントローラがかけた。sramのシミュレータがちゃんとsramの動作を
  模倣しているのならうまく動作するだろう。
* I/Oも少し確認したが大丈夫そう。明日実機でループバックのテストでも
  してみる。
* 残るは浮動小数演算。

#----------------------------------------------------------------------#
2012年  2月 15日 水曜日 17:34:07 JST

* 進捗メール

	fsqrt_table, finv_table, prom,ramをCoreGeneratorで組み込んで、
	fib30, float.sが期待通りに出力されることを確認。

	レイトレで必要なRAMの分だけBlockRAMを確保しようとしたら無理だった
	ので、SRAMの組み込みに取り掛かります。

	I/Oはinputも動いているけど、十分にはテストできていない。
	大方大丈夫とは思う。outputは大丈夫そう。

	浮動小数演算が少し誤差っている。

	まとめると、
	- SRAMを動作させる。
	- input。コンパイラとの調整とストールの仕組みの確認。
	- fmul, faddの修正。
	でレイトレが動くはず。

	ひとまずSRAMさえできればレイトレを動かすテストができるので、
	滞りなければ明日画像を出力させる予定。

#----------------------------------------------------------------------#
2012年  2月 15日 水曜日 13:12:31 JST

* ram,tableまわり修正。
* すこしは自然な形なっただろうか。

########################################################################
2012年  2月 14日 火曜日 23:02:29 JST

* ramまわりを書いた。これでramもCoreGeneratorで作れるはず。

* float.s fmulちょっと修正。あまり変わらず。

* fsub
	3FC90FDA - 406074E4 = BFF7D9EE -- ok 
	40490FDA - 3FF7D9EE = 3F9A45C6 -- ok
* fmul
	cnt:da 3F9A45C6 * 3F000000 = 3F1A4001 -- ans: 3F1A45C7

* fmul修正。
  結果  : 0x44604264 
  sim   : 0x44604260 乗算は自作。加算はC組み込み。
  ocaml : 0x44604263

#----------------------------------------------------------------------#
2012年  2月 14日 火曜日 20:12:28 JST

* fsqrt, finvのテーブルをCoreGeneratorのSinglePortRomに置き換える、
  準備ができた。MainClockの２倍のクロックを90度ずらすというやり方が
  自分には判断できないが、不自然(一般的でない)であるかもしれない。

* ramもやってみる。fpuのテーブルのことを考えて、安全な範囲で。
* ram size 32 x 131072 (128 KW = 512 KB = 0.5 MB)

#----------------------------------------------------------------------#
2012年  2月 14日 火曜日 18:00:55 JST

* 実機でfib 30が確認できたのは収穫。
* これからclkをいじる。
* 論理合成がやはりやや時間がかかるので、CoreGeneratorをうまく
  活用できるようにする。
* clkdllの使い方は概ねわかった。

* 木戸が言ってた、勝手にBlockRAMに推論されるってのが起こっていたよう。

#----------------------------------------------------------------------#
2012年  2月 14日 火曜日 14:49:22 JST

* fib6, fib30が実機で動いた。
* float を実機で出力させたが、
  -2097296
  である。

########################################################################
2012年  2月 13日 月曜日 00:20:51 JST

* パイプライン化に踏み込むかどうか。

########################################################################
2012年  2月 12日 日曜日 23:05:09 JST

* I/O命令をword命令だけにしようかと考えた(その方が制御線が少なくて、
  すっきりする)が、やはり柔軟性にかけるので両方ともできるようにする。

  - input wordならheadを4つ進め、input byteなら1つすすめる。
    input byteでも上位bitに値が入っている可能性あり。

  - output wordならレジスタの4bytesをsendbufに積む。
    エンディアンはコンパイラ係深堀に任せる。
	統一感をもたせるならリトルエンディアン。
	output byteならレジスタの下位1byteをsendbufに積む。


#----------------------------------------------------------------------#
2012年  2月 12日 日曜日 00:33:47 JST

* inputを少しテストして修正。ストールの仕組みもひとまずできた。
* あとの変更は実機でのテストをしてからにしよう。

* fpuの誤差についてのメモ。
  float.s 実行時

  ocaml : 0x44604263 => 897.03710937500000000000
  sim   : 0x44604260 => 897.03710937500000000000
  "0100010001100000010000 1001100000
  結果  : 0x44604148 => 897.02001953125000000000
  "0100010001100000010000 0101001000

* float.s でつかわれる命令。

    fadd: 0.004396          4
    fsub: 0.030769         28
    fmul: 0.009890          9
    fdiv: 0.013187         12
   fsqrt: 0.001099          1
    fmov: 0.067033         61
    fneg: 0.006593          6
    fldi: 0.043956         40
    fjeq: 0.003297          3
    fsti: 0.021978         20
    fjlt: 0.037363         34

* .lstファイルでシミュレータ実行時のレジスタの値等を確認できる。

########################################################################
2012年  2月 11日 土曜日 17:38:44 JST

* FJLT 修正。

* 考えるべき事項
	- read_int, read_float, write_int, write_float
		(input_int, io_read_intとかio関係とわかるネームのほうが好み)
	- input時のストール, inputのテストが不十分
	- 浮動小数演算の誤差
	- rom, ramの確保の仕方(core generationの使い方)
	- clkのいじりかた
	- sram?
	- 実機で動くか
	- コンテスト時のルールに則ること
	- 試験

	- パイプライン
	- solver (xsim solver とかつくってみたい)

#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 16:21:48 JST

* input時のストールを組み込むかどうか。
* read_int, read_floatが追加するかも。

#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 15:14:20 JST

* 今日明日明後日はテスト勉強をメインとする。
* 火曜はレイトレのテストをする。まずはfibとfloatでテストすること。
* inputの修正が必要。
* romとramの作り方を教わる。
* clkのいじり方を教わる。

#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 06:31:26 JST

* 寝付けないので、少し整備。配列がでかいとテストがしにくいので、
  配列のサイズを変えるのを簡潔にした。

#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 03:49:35 JST

* min-rt contest.sld シミュレータ cnt : 1 446 479 454
* 1 446 479 454[命令] * 5 [clk/命令] = 7 232 397 270 [clk]
* x [ns/clk] として x * 7.232 397 270 [s]

* ちなみにxsimにて1.140 s


#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 03:12:24 JST

* あとはI/Oとramを十分に確保できればレイトレも動作するはず。
* 精度は置いとく。
 16386  49156 154757 contest.ppm
    35    325   1137 contest.sld

#----------------------------------------------------------------------#
2012年  2月 11日 土曜日 02:50:05 JST

* fpuすべて組み込んで動いている。
* 精度の問題が残る。

########################################################################
2012年  2月 10日 金曜日 20:12:14 JST

* ようやくfadd、fsub動いた！ghdlシミュレータね。
* 木戸のを参考にfaddを修正。for文とか初めて使った。
* あとはfmul、finv、fsqrt。

#----------------------------------------------------------------------#
2012年  2月 10日 金曜日 13:31:53 JST

* 12時間睡眠確保！

* fpuの組み込みは安定した。
  faddがbound check failure ではじかれる。

########################################################################
2012年  2月  9日 木曜日 12:48:25 JST

* 浮動小数点数演算をおおよそ組み込んだ。
  fadd,fsub,fmul,fdiv,fsqrtはこれから。
* デバッグが大変そうだ。

#----------------------------------------------------------------------#
2012年  2月  9日 木曜日 11:16:39 JST

* レイトレにcontestを入力してramは128KBでも動作した(もちろんシミュレータ
  )。
* 浮動小数点数演算以外は安定している。
* I/Oはinputがあまりテストできていない。
* もう少し。

#----------------------------------------------------------------------#
2012年  2月  9日 木曜日 06:31:11 JST

* 寝付けない。
#----------------------------------------------------------------------#
2012年  2月  9日 木曜日 05:05:47 JST

* INPUT,OUTPUT命令をいれたテスト(ghdlシミュレータ)で期待通りに動いた。
  まだ、バッファの拡張もしくは循環はさせていない。

* 少し命令を揃える。浮動小数点数についても考える。
* とりあえず寝る。

#----------------------------------------------------------------------#
2012年  2月  9日 木曜日 03:34:39 JST

* INPUTでストールする場合は、
  decode phase : opcode=INPUT and NYET = '1'
  exec phase : ---- ここでストップ。NYET='0'で再開。
  とか。

#----------------------------------------------------------------------#
2012年  2月  9日 木曜日 02:07:45 JST

* OUTPUTの機構ができてきた。1KBまでならうまく送れるのではないか。
  リングバッファにするか、メモリを大きく確保する必要が出てくるだろう。

* 問題はINPUTのデータ待ちをするところ。input命令時にデータが入ってない、
  ことは有りうるのだろうか。転送開始の合図をこちらが送ったら、sldのデータ
  を送ってくるルールなはずだから、inputが相当遅くない限り考えなくてもいい
  かも。とりあえず、そういう状況になる場合を除外しておく。

* UART: Universal Asynchronous Receiver Transmitter

########################################################################
2012年  2月  8日 水曜日 21:09:36 JST

* cpuのarchitecture名RTLは参考にしたサイトのものであるが、
  RTL: Register Transfer Level という意味。

#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 20:09:37 JST

* バイトアドレッシングにした。
* リトルエンディアン。

* I/Oやる。
* 今 => rom: 64KB, ram: 16KB, I/Obuf: ??KB
  sld(O(1KB)), ppm(O(100KB))の大きさを考えると、200KB程あれば十分。 
  過去の資料を見ると、recieve bufferを大きく確保していたりするけど
  計算間違っているだろうか。sldファイルはせいぜい2KB。

* ramはfibでの十分量でありもっと大きくする必要がある。

#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 19:07:03 JST

* バイトアドレッシングにする。今のところ命令種は限定されていて、
  - ld,st系はload word, store word
  - output, inputはoutput byte, input byte
  であり、コンパイラはそれに従っている。
* リトルエンディアン
* 編集前にpush


#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 16:30:08 JST 

* romは2^16 Words(2^6=64KB)もあればレイトレでも十分。pcも16bitで大丈夫。
  今のところは32bit 。

* I/O MMIO(Memory Mapped I/O)
* バイトアドレッシングにする。



#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 13:50:19 JST

- 実機でfib 6(ans:8), fib 9(ans:34), fib 15(ans:610),
  fib 30(ans:832040)をテスト
  I/Oが整備できてないから、下１桁の値だけ出力するような
  テストしかできていないが、どれも正しく8,4,0,0が出力されている。
  下１桁だけだが、vsim上で期待通りに動いているので、
  ちゃんと動いていると言える。

- ise,vsimでのテスト環境の整備ができた。

- 今後のdebugのためにもI/Oを整える。

[現状]
- 初期化、fibで使う命令列は大方正しい。
- メモリ(ram)の確保: fibでは十分。
- I/Oができていない。
- 安定している命令数20(output を含む)

[tmpl/op_complete_list.txt]
- 20
- MVLO - MVHI - ADD - SUB
- ADDI - SUBI - MULI - SLLI
- SRLI - MUL - LDI - JEQ
- JNE - JLT - JMP - LDI
- STI - CALL - (OUTPUT) - HALT

#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 07:12:26 JST

- 実機でテストするときは
- ライブラリの宣言の修正。
- clkの入れ方。
- wtimeの値(top.vhd u232c.vhd)
を変更する必要がある。

#----------------------------------------------------------------------#
2012年  2月  8日 水曜日 05:29:54 JST

- 実機は甘くなかった。
- testしていた状況を実機上で再現できていないせい
  だと考えられるのがまだ救い。
  resetの仕方と簡単なI/Oができれば動くだろう。

########################################################################
2012年  2月  7日 火曜日 23:45:15 JST

- fib 9用のI/Oができたはず。
- 次はI/Oを整えるべき。

#----------------------------------------------------------------------#
2012年  2月  7日 火曜日 21:39:26 JST

- ghdlシミュレータ上でfib動作。
- 色々ミスってた。

#----------------------------------------------------------------------#
2012年  2月  7日 火曜日 19:11:32 JST

- call, return はハードウェアでサポートする。
- fibで使われる操作は揃ったはず。
- これからfibのテスト。
- 未だにghdlシミュレータでのみのテスト。
- おそらくワードアドレッシング

#----------------------------------------------------------------------#
2012年  2月  7日 火曜日 14:59:58 JST

* テンプレートができた。宣言は共通のものを使うことで編集ミスを
  なくせるが、制御線をつなぐところは手動でやらなくてはいけない。
  どこまでテンプレートに任せるか考えどこ。とりあえずテンプレートは終了。

命令を揃える。
($ sudo apt-get install gtkwave ghdl)
$ make
$ make push
$ make wave
$ make rel (make reload)

#----------------------------------------------------------------------#
2012年  2月  7日 火曜日 12:53:50 JST

開発環境の整備。
・テンプレートの使用。
- test環境整備。
- コンポーネントの宣言のミスをなくす。

失敗すると困るのでひとまずpush。

#----------------------------------------------------------------------#
2012年  2月  7日 火曜日 02:39:19 JST

ステージ構成を少し変更。こうしないとレジスタからアドレスを指定しづらい。
基本的なパイプラインのステージ構成といわれるものを参考にした。

- fetch phase
- decode phase
- exec phase 
- memory access phase
- write back phase

ramが大体できたはず。

次は命令を揃える。

基本的な動作はするが、まだ確認すべきことがある状態。
命令を揃えつつデバッグする。

########################################################################
2012年  2月  6日 月曜日 21:55:04 JST

できた。
・registerを32個に拡張。
・LinkRegister
・ゼロレジスタ
・初期化実装完了。

これから。
・rom、ramの実装の仕方。
・メガファンクションとは

まださき。
・I/O
・命令を揃える。

#----------------------------------------------------------------------#
2012年  2月  6日 月曜日 19:35:00 JST

ghdlシミュレータでは動作。
初期化を実装する前。


#----------------------------------------------------------------------#
2012年  2月  6日 月曜日 14:38:23 JST
下のアドレスに基づいてつくったコア。
http://laputa.cs.shinshu-u.ac.jp/~yizawa/design_cpu/index.html

ghdlシミュレータで正しく動作したとこまででpush。
実機で動くかは試していない。

($ sudo apt-get install gtkwave ghdl)
$ make
$ make wave


top.vhd : cpuにクロックとIOを入れる。
cpu15e.vhd : コアコントローラ？なぜ15？
clk_gen.vhd : 4つのclkを生成。

## fetch phase
	fetch.vhd : PROM_OUT <- ROM[PC]
## decode phase
	decode.vhd : PROM_OUT からOPCODEとOP_DATAを分離。
	reg_dc.vhd : 引数となるレジスタA, B、又、そのインデックスを返す。
	ram_dc.vhd : 与えられたアドレスのRAMの中身を返す。
## exec phase 
	exec.vhd : 命令実行。
## write-back phase
	reg_wb.vhd : 書き込み。
	ram_wb.vhd : 書き込み。



########################################################################
2012年  2月  5日 日曜日 17:11:27 JST

ん。
